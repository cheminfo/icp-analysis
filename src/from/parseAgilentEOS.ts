import type { BinaryData, ICPDilution, ICPResult } from 'cheminfo-types';
import { read, utils } from 'xlsx';

interface SampleResult {
  elements: ICPResult[];
  reference: string;
}

interface ParseAgilentEOSOptions {
  dilution?: ICPDilution;
}

/**
 * Parse an excel spreadsheet generated by Agilent EOS.
 * @param binaryData - The binary data of the Excel spreadsheet.
 * @param options - Options for parsing, including dilution parameters.
 * @returns An array of parsed sample results.
 */
export function parseAgilentEOS(
  binaryData: BinaryData,
  options: ParseAgilentEOSOptions = {},
): SampleResult[] {
  const workbook = read(binaryData, { type: 'array' });

  const { dilution = {} } = options;
  // summary is on Sheet2
  const sheetName = workbook.SheetNames[1];
  const sheet = sheetName ? workbook.Sheets[sheetName] : undefined;
  if (!sheet) {
    throw new Error('Expected at least 2 sheets in the workbook');
  }
  const matrix: Array<Array<string | number>> = utils.sheet_to_json(sheet, {
    header: 1,
  });
  const header = parseHeader(matrix[0]);
  const samples = [];
  for (const line of matrix.slice(1).filter((line) => line[2])) {
    const sample = {
      elements: [] as ICPResult[],
      reference: line[2] as string,
    };
    for (let i = 3; i < header.length; i++) {
      const result = structuredClone(header[i]);
      result.experimentalConcentration.value = Number.parseFloat(`${line[i]}`);
      if (dilution.factor) {
        result.sampleConcentration = {
          value: result.experimentalConcentration.value * dilution.factor,
          units: result.experimentalConcentration.units,
        };
      }
      if (dilution.factor || dilution.solvent) {
        result.dilution = dilution;
      }
      sample.elements.push(result);
    }
    samples.push(sample);
  }
  return samples;
}

function parseHeader(header: any) {
  return header.map((item: string) => {
    if (item.includes('.')) {
      const parts = item.split(' ');
      return {
        element: parts[0],
        wavelength: {
          value: Number(parts[1]),
          units: parts[2],
        },
        experimentalConcentration: {
          value: undefined,
          units: parts[3] === 'ppm' ? 'mg/l' : parts[3],
        },
      };
    }
    return { label: item };
  });
}
